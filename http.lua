--credit: sapphyrus
local a=loadstring([===[local a={}local b=_G.bit32 and _G.bit32.extract;if not b then if _G.bit then local c,d,e=_G.bit.lshift,_G.bit.rshift,_G.bit.band;b=function(f,g,h)return e(d(f,g),c(1,h)-1)end elseif _G._VERSION=="Lua 5.1"then b=function(f,g,h)local i=0;local j=2^g;for k=0,h-1 do local l=j+j;if f%l>=j then i=i+2^k end;j=l end;return i end else b=load[[return function( v, from, width )return ( v >> from ) & ((1 << width) - 1)end]]()end end;function a.makeencoder(m,n,o)local p={}for q,r in pairs{[0]='A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9',m or'+',n or'/',o or'='}do p[q]=r:byte()end;return p end;function a.makedecoder(m,n,o)local s={}for q,t in pairs(a.makeencoder(m,n,o))do s[t]=q end;return s end;local u=a.makeencoder()local v=a.makedecoder()local r,w=string.char,table.concat;function a.encode(x,p,y)p=p or u;local z,A,B={},1,#x;local C=B%3;local D={}for k=1,B-C,3 do local E,F,G=x:byte(k,k+2)local f=E*0x10000+F*0x100+G;local H;if y then H=D[f]if not H then H=r(p[b(f,18,6)],p[b(f,12,6)],p[b(f,6,6)],p[b(f,0,6)])D[f]=H end else H=r(p[b(f,18,6)],p[b(f,12,6)],p[b(f,6,6)],p[b(f,0,6)])end;z[A]=H;A=A+1 end;if C==2 then local E,F=x:byte(B-1,B)local f=E*0x10000+F*0x100;z[A]=r(p[b(f,18,6)],p[b(f,12,6)],p[b(f,6,6)],p[64])elseif C==1 then local f=x:byte(B)*0x10000;z[A]=r(p[b(f,18,6)],p[b(f,12,6)],p[64],p[64])end;return w(z)end;function a.decode(I,s,y)s=s or v;local J='[^%w%+%/%=]'if s then local m,n;for t,q in pairs(s)do if q==62 then m=t elseif q==63 then n=t end end;J=('[^%%w%%%s%%%s%%=]'):format(r(m),r(n))end;I=I:gsub(J,'')local D=y and{}local z,A={},1;local B=#I;local K=I:sub(-2)=='=='and 2 or I:sub(-1)=='='and 1 or 0;for k=1,K>0 and B-4 or B,4 do local E,F,G,L=I:byte(k,k+3)local H;if y then local M=E*0x1000000+F*0x10000+G*0x100+L;H=D[M]if not H then local f=s[E]*0x40000+s[F]*0x1000+s[G]*0x40+s[L]H=r(b(f,16,8),b(f,8,8),b(f,0,8))D[M]=H end else local f=s[E]*0x40000+s[F]*0x1000+s[G]*0x40+s[L]H=r(b(f,16,8),b(f,8,8),b(f,0,8))end;z[A]=H;A=A+1 end;if K==1 then local E,F,G=I:byte(B-3,B-1)local f=s[E]*0x40000+s[F]*0x1000+s[G]*0x40;z[A]=r(b(f,16,8),b(f,8,8))elseif K==2 then local E,F=I:byte(B-3,B-2)local f=s[E]*0x40000+s[F]*0x1000;z[A]=r(b(f,16,8))end;return w(z)end;return a]===])()local assert,pcall,xpcall,error,setmetatable,tostring,tonumber,type,pairs,ipairs=assert,pcall,xpcall,error,setmetatable,tostring,tonumber,type,pairs,ipairs;local b,c,d,e,f,g=ffi.typeof,ffi.sizeof,ffi.cast,ffi.cdef,ffi.string,ffi.gc;local h,i,j,k=string.lower,string.len,string.find,string.format;local l=a.encode;local m,n,o;do if not pcall(ffi.sizeof,"scallfuck")then e([[typedef uint64_t scallfuck; struct abc_vtbl {void(__thiscall *run1)(struct nigcall *, void *, bool, uint64_t);void(__thiscall *run2)(struct nigcall *, void *);int(__thiscall *get_size)(struct nigcall *);}; struct nigcall {struct abc_vtbl *vtbl;uint8_t flags;int id;uint64_t api_call_handle;struct abc_vtbl vtbl_storage[1];};]])end;local p={[-1]="No failure",[0]="Steam gone",[1]="Network failure",[2]="Invalid handle",[3]="Mismatched callback"}local q,r;local s,t;local u;local v=b("struct nigcall")local w=c(v)local x=b("struct nigcall[1]")local y=b("struct nigcall*")local z=b("uintptr_t")local A={}local B={}local C={}local function D(E)return tostring(tonumber(d(z,E)))end;local function F(self,G,H)if H then H=p[u(self.api_call_handle)]or"Unknown error"end;self.api_call_handle=0;xpcall(function()local I=D(self)local J=A[I]if J~=nil then xpcall(J,error,G,H)end;if B[I]~=nil then A[I]=nil;B[I]=nil end end,error)end;local function K(self,G,H,L)if L==self.api_call_handle then F(self,G,H)end end;local function M(self,G)F(self,G,false)end;local function N(self)return w end;local function O(self)if self.api_call_handle~=0 then r(self,self.api_call_handle)self.api_call_handle=0;local I=D(self)A[I]=nil;B[I]=nil end end;pcall(ffi.metatype,v,{__gc=O,__index={cancel=O}})local P=d("void(__thiscall *)(struct nigcall *, void *, bool, uint64_t)",K)local Q=d("void(__thiscall *)(struct nigcall *, void *)",M)local R=d("int(__thiscall *)(struct nigcall *)",N)function m(L,J,S)assert(L~=0)local T=x()local U=d(y,T)U.vtbl_storage[0].run1=P;U.vtbl_storage[0].run2=Q;U.vtbl_storage[0].get_size=R;U.vtbl=U.vtbl_storage;U.api_call_handle=L;U.id=S;local I=D(U)A[I]=J;B[I]=T;q(U,L)return U end;function n(S,J)assert(C[S]==nil)local T=x()local U=d(y,T)U.vtbl_storage[0].run1=P;U.vtbl_storage[0].run2=Q;U.vtbl_storage[0].get_size=R;U.vtbl=U.vtbl_storage;U.api_call_handle=0;U.id=S;local I=D(U)A[I]=J;C[S]=T;s(U,S)end;local function V(W,X,Y,Z,_)local a0=mem.FindPattern(W,X)or error("signature not found",2)local a1=d("uintptr_t",a0)if Z~=nil and Z~=0 then a1=a1+Z end;if _~=nil then for a2=1,_ do a1=d("uintptr_t*",a1)[0]if a1==nil then return error("signature not found")end end end;return d(Y,a1)end;local function a3(U,a4,type)return d(type,d("void***",U)[0][a4])end;q=V("steam_api.dll","55 8B EC 83 3D ?? ?? ?? ?? ?? 7E 0D 68 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 5D C3 FF 75 10","void(__cdecl*)(struct nigcall *, uint64_t)")r=V("steam_api.dll","55 8B EC FF 75 10 FF 75 0C","void(__cdecl*)(struct nigcall *, uint64_t)")s=V("steam_api.dll","55 8B EC 83 3D ?? ?? ?? ?? ?? 7E 0D 68 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 5D C3 C7 05","void(__cdecl*)(struct nigcall *, int)")t=V("steam_api.dll","55 8B EC 83 EC 08 80 3D","void(__cdecl*)(struct nigcall *)")o=V("client.dll","B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 3D ?? ?? ?? ?? ?? 0F 84","uintptr_t",1,1)local a5=d("uintptr_t*",o)[3]local a6=a3(a5,12,"int(__thiscall*)(void*, scallfuck)")function u(a7)return a6(a5,a7)end;callbacks.Register('Unload',function()for I,a8 in pairs(B)do local U=d(y,a8)O(U)end;for I,a8 in pairs(C)do local U=d(y,a8)t(U)end end)end;if not pcall(c,"aaa")then e('typedef uint32_t aaa; typedef uint32_t fff;  enum rrre { invalidfuc, fuck, okdude, postingnig, ufjs, itus, iits, nnnca, };  struct coolstory { aaa(__thiscall *story)(uintptr_t, enum rrre, const char *); bool(__thiscall *funny)(uintptr_t, aaa, uint64_t); bool(__thiscall *funnyman)(uintptr_t, aaa, uint32_t); bool(__thiscall *uuufa)(uintptr_t, aaa, const char *, const char *); bool(__thiscall *you)(uintptr_t, aaa, const char *, const char *); bool(__thiscall *think)(uintptr_t, aaa, scallfuck *); bool(__thiscall *this)(uintptr_t, aaa, scallfuck *); bool(__thiscall *isis)(uintptr_t, aaa); bool(__thiscall *eeeez)(uintptr_t, aaa); bool(__thiscall *shesh)(uintptr_t, aaa, const char *, uint32_t *); bool(__thiscall *sheesh)(uintptr_t, aaa, const char *, uint8_t *, uint32_t); bool(__thiscall *sheeesh)(uintptr_t, aaa, uint32_t *); bool(__thiscall *sheeeesh)(uintptr_t, aaa, uint8_t *, uint32_t); bool(__thiscall *sheeeeesh)(uintptr_t, aaa, uint32_t, uint8_t *, uint32_t); bool(__thiscall *sheeeeeesh)(uintptr_t, aaa); bool(__thiscall *okiam)(uintptr_t, aaa, float *); bool(__thiscall *almost)(uintptr_t, aaa, const char *, uint8_t *, uint32_t); fff(__thiscall *dddone)(uintptr_t, bool); bool(__thiscall *seeifit)(uintptr_t, fff); bool(__thiscall *still)(uintptr_t, fff, const char *, const char *, const char *); bool(__thiscall *works)(uintptr_t, aaa, fff); bool(__thiscall *after)(uintptr_t, aaa, const char *); bool(__thiscall *thisthing)(uintptr_t, aaa, bool); bool(__thiscall *prob)(uintptr_t, aaa, uint32_t); bool(__thiscall *notwork)(uintptr_t, aaa, bool *pbWasTimedOut); };')end;local a9={get=ffi.C.fuck,head=ffi.C.okdude,post=ffi.C.postingnig,put=ffi.C.ufjs,delete=ffi.C.itus,options=ffi.C.iits,patch=ffi.C.nnnca}local aa={[100]="Continue",[101]="Switching Protocols",[102]="Processing",[200]="OK",[201]="Created",[202]="Accepted",[203]="Non-Authoritative Information",[204]="No Content",[205]="Reset Content",[206]="Partial Content",[207]="Multi-Status",[208]="Already Reported",[250]="Low on Storage Space",[226]="IM Used",[300]="Multiple Choices",[301]="Moved Permanently",[302]="Found",[303]="See Other",[304]="Not Modified",[305]="Use Proxy",[306]="Switch Proxy",[307]="Temporary Redirect",[308]="Permanent Redirect",[400]="Bad Request",[401]="Unauthorized",[402]="Payment Required",[403]="Forbidden",[404]="Not Found",[405]="Method Not Allowed",[406]="Not Acceptable",[407]="Proxy Authentication Required",[408]="Request Timeout",[409]="Conflict",[410]="Gone",[411]="Length Required",[412]="Precondition Failed",[413]="Request Entity Too Large",[414]="Request-URI Too Long",[415]="Unsupported Media Type",[416]="Requested Range Not Satisfiable",[417]="Expectation Failed",[418]="I'm a teapot",[420]="Enhance Your Calm",[422]="Unprocessable Entity",[423]="Locked",[424]="Failed Dependency",[424]="Method Failure",[425]="Unordered Collection",[426]="Upgrade Required",[428]="Precondition Required",[429]="Too Many Requests",[431]="Request Header Fields Too Large",[444]="No Response",[449]="Retry With",[450]="Blocked by Windows Parental Controls",[451]="Parameter Not Understood",[451]="Unavailable For Legal Reasons",[451]="Redirect",[452]="Conference Not Found",[453]="Not Enough Bandwidth",[454]="Session Not Found",[455]="Method Not Valid in This State",[456]="Header Field Not Valid for Resource",[457]="Invalid Range",[458]="Parameter Is Read-Only",[459]="Aggregate Operation Not Allowed",[460]="Only Aggregate Operation Allowed",[461]="Unsupported Transport",[462]="Destination Unreachable",[494]="Request Header Too Large",[495]="Cert Error",[496]="No Cert",[497]="HTTP to HTTPS",[499]="Client Closed Request",[500]="Internal Server Error",[501]="Not Implemented",[502]="Bad Gateway",[503]="Service Unavailable",[504]="Gateway Timeout",[505]="HTTP Version Not Supported",[506]="Variant Also Negotiates",[507]="Insufficient Storage",[508]="Loop Detected",[509]="Bandwidth Limit Exceeded",[510]="Not Extended",[511]="Network Authentication Required",[551]="Option not supported",[598]="Network read timeout error",[599]="Network connect timeout error"}local ab={"params","body","json"}local ac=2101;local ad=2102;local ae=2103;local function af()local ag=d("uintptr_t*",o)[12]if ag==0 or ag==nil then return error("find_isteamhttp failed")end;local ah=d("struct coolstory**",ag)[0]if ah==0 or ah==nil then return error("find_isteamhttp failed")end;return ag,ah end;local function ai(aj,ak)return function(...)return aj(ak,...)end end;local al=b('struct {aaa m_hRequest;uint64_t m_ulContextValue;bool m_bRequestSuccessful;int m_eStatusCode;uint32_t m_unBodySize;} *')local am=b('struct {aaa m_hRequest;uint64_t m_ulContextValue;} *')local an=b('struct {aaa m_hRequest;uint64_t m_ulContextValue;uint32_t m_cOffset;uint32_t m_cBytesReceived;} *')local ao=b('struct {fff m_hCookieContainer;}')local ap=b("scallfuck[1]")local aq=b("const char[?]")local ar=b("uint8_t[?]")local as=b("unsigned int[?]")local at=b("bool[1]")local au=b("float[1]")local av,aw=af()local ax=ai(aw.story,av)local ay=ai(aw.funny,av)local az=ai(aw.funnyman,av)local aA=ai(aw.uuufa,av)local aB=ai(aw.you,av)local aC=ai(aw.think,av)local aD=ai(aw.this,av)local aE=ai(aw.isis,av)local aF=ai(aw.eeeez,av)local aG=ai(aw.shesh,av)local aH=ai(aw.sheesh,av)local aI=ai(aw.sheeesh,av)local aJ=ai(aw.sheeeesh,av)local aK=ai(aw.sheeeeesh,av)local aL=ai(aw.sheeeeeesh,av)local aM=ai(aw.okiam,av)local aN=ai(aw.almost,av)local aO=ai(aw.dddone,av)local aP=ai(aw.seeifit,av)local aQ=ai(aw.still,av)local aR=ai(aw.works,av)local aS=ai(aw.after,av)local aT=ai(aw.thisthing,av)local aU=ai(aw.prob,av)local aV=ai(aw.notwork,av)local aW,aX={},false;local aY,aZ=false,{}local a_,b0=false,{}local b1=setmetatable({},{__mode="k"})local b2,b3=setmetatable({},{__mode="k"}),setmetatable({},{__mode="v"})local b4={}local b5={__index=function(b6,b7)local b8=b2[b6]if b8==nil then return end;b7=tostring(b7)if b8.m_hRequest~=0 then local b9=as(1)if aG(b8.m_hRequest,b7,b9)then if b9~=nil then b9=b9[0]if b9<0 then return end;local ba=ar(b9)if aH(b8.m_hRequest,b7,ba,b9)then b6[b7]=f(ba,b9-1)return b6[b7]end end end end end,__metatable=false}local bb={__index={set_cookie=function(bc,bd,be,b7,a8)local a7=b1[bc]if a7==nil or a7.m_hCookieContainer==0 then return end;aQ(a7.m_hCookieContainer,bd,be,tostring(b7).."="..tostring(a8))end},__metatable=false}local function bf(a7)if a7.m_hCookieContainer~=0 then aP(a7.m_hCookieContainer)a7.m_hCookieContainer=0 end end;local function bg(b8)if b8.m_hRequest~=0 then aL(b8.m_hRequest)b8.m_hRequest=0 end end;local function bh(bi,...)aL(bi)return error(...)end;local function bj(b8,bk,bl,bm,...)local bn=b3[b8.m_hRequest]if bn==nil then bn=setmetatable({},b5)b3[b8.m_hRequest]=bn end;b2[bn]=b8;bm.headers=bn;aX=true;xpcall(bk,error,bl,bm,...)aX=false end;local function bo(G,H)if G==nil then return end;local b8=d(al,G)if b8.m_hRequest~=0 then local bk=aW[b8.m_hRequest]if bk~=nil then aW[b8.m_hRequest]=nil;b0[b8.m_hRequest]=nil;aZ[b8.m_hRequest]=nil;if bk then local bl=H==false and b8.m_bRequestSuccessful;local bp=b8.m_eStatusCode;local bq={status=bp}local br=b8.m_unBodySize;if bl and br>0 then local ba=ar(br)if aJ(b8.m_hRequest,ba,br)then bq.body=f(ba,br)end elseif not b8.m_bRequestSuccessful then local bs=at()aV(b8.m_hRequest,bs)bq.timed_out=bs~=nil and bs[0]==true end;if bp>0 then bq.status_message=aa[bp]or"Unknown status"elseif H then bq.status_message=k("IO Failure: %s",H)else bq.status_message=bq.timed_out and"Timed out"or"Unknown error"end;bj(b8,bk,bl,bq)end;bg(b8)end end end;local function bt(G,H)if G==nil then return end;local b8=d(am,G)if b8.m_hRequest~=0 then local bk=aZ[b8.m_hRequest]if bk then bj(b8,bk,H==false,{})end end end;local function bu(G,H)if G==nil then return end;local b8=d(an,G)if b8.m_hRequest~=0 then local bk=b0[b8.m_hRequest]if b0[b8.m_hRequest]then local bm={}local bv=au()if aM(b8.m_hRequest,bv)then bm.download_progress=tonumber(bv[0])end;local ba=ar(b8.m_cBytesReceived)if aK(b8.m_hRequest,b8.m_cOffset,ba,b8.m_cBytesReceived)then bm.body=f(ba,b8.m_cBytesReceived)end;bj(b8,bk,H==false,bm)end end end;local function bw(bx,be,by,callbacks)if type(by)=="function"and callbacks==nil then callbacks=by;by={}end;by=by or{}local bx=a9[h(tostring(bx))]if bx==nil then return error("invalid HTTP method")end;if type(be)~="string"then return error("URL has to be a string")end;local bz,bA,bB;if type(callbacks)=="function"then bz=callbacks elseif type(callbacks)=="table"then bz=callbacks.completed or callbacks.complete;bA=callbacks.headers_received or callbacks.headers;bB=callbacks.data_received or callbacks.data;if bz~=nil and type(bz)~="function"then return error("callbacks.completed callback has to be a function")elseif bA~=nil and type(bA)~="function"then return error("callbacks.headers_received callback has to be a function")elseif bB~=nil and type(bB)~="function"then return error("callbacks.data_received callback has to be a function")end else return error("callbacks has to be a function or table")end;local bi=ax(bx,be)if bi==0 then return error("Failed to create HTTP request")end;local bC=false;for a2,I in ipairs(ab)do if by[I]~=nil then if bC then return error("can only set options.params, options.body or options.json")else bC=true end end end;local bD;if by.json~=nil then local bE;bE,bD=pcall(json.stringify,by.json)if not bE then return error("options.json is invalid: "..bD)end end;local bF=by.network_timeout;if bF==nil then bF=10 end;if type(bF)=="number"and bF>0 then if not az(bi,bF)then return bh(bi,"failed to set network_timeout")end elseif bF~=nil then return bh(bi,"options.network_timeout has to be of type number and greater than 0")end;local bG=by.absolute_timeout;if bG==nil then bG=30 end;if type(bG)=="number"and bG>0 then if not aU(bi,bG*1000)then return bh(bi,"failed to set absolute_timeout")end elseif bG~=nil then return bh(bi,"options.absolute_timeout has to be of type number and greater than 0")end;local bH=bD~=nil and"application/json"or"text/plain"local bI;local bn=by.headers;if type(bn)=="table"then for b7,a8 in pairs(bn)do b7=tostring(b7)a8=tostring(a8)local bJ=h(b7)if bJ=="content-type"then bH=a8 elseif bJ=="authorization"then bI=true end;if not aA(bi,b7,a8)then return bh(bi,"failed to set header "..b7)end end elseif bn~=nil then return bh(bi,"options.headers has to be of type table")end;local bK=by.authorization;if type(bK)=="table"then if bI then return bh(bi,"Cannot set both options.authorization and the 'Authorization' header.")end;local bL,bM=bK[1],bK[2]local bN=k("Basic %s",l(k("%s:%s",tostring(bL),tostring(bM)),"base64"))if not aA(bi,"Authorization",bN)then return bh(bi,"failed to apply options.authorization")end elseif bK~=nil then return bh(bi,"options.authorization has to be of type table")end;local bO=bD or by.body;if type(bO)=="string"then local bP=i(bO)if not aN(bi,bH,d("unsigned char*",bO),bP)then return bh(bi,"failed to set post body")end elseif bO~=nil then return bh(bi,"options.body has to be of type string")end;local bQ=by.params;if type(bQ)=="table"then for b7,a8 in pairs(bQ)do b7=tostring(b7)if not aB(bi,b7,tostring(a8))then return bh(bi,"failed to set parameter "..b7)end end elseif bQ~=nil then return bh(bi,"options.params has to be of type table")end;local bR=by.require_ssl;if type(bR)=="boolean"then if not aT(bi,bR==true)then return bh(bi,"failed to set require_ssl")end elseif bR~=nil then return bh(bi,"options.require_ssl has to be of type boolean")end;local bS=by.user_agent_info;if type(bS)=="string"then if not aS(bi,tostring(bS))then return bh(bi,"failed to set user_agent_info")end elseif bS~=nil then return bh(bi,"options.user_agent_info has to be of type string")end;local bT=by.cookie_container;if type(bT)=="table"then local a7=b1[bT]if a7~=nil and a7.m_hCookieContainer~=0 then if not aR(bi,a7.m_hCookieContainer)then return bh(bi,"failed to set user_agent_info")end else return bh(bi,"options.cookie_container has to a valid cookie container")end elseif bT~=nil then return bh(bi,"options.cookie_container has to a valid cookie container")end;local bU=aC;local bV=by.stream_response;if type(bV)=="boolean"then if bV then bU=aD;if bz==nil and bA==nil and bB==nil then return bh(bi,"a 'completed', 'headers_received' or 'data_received' callback is required")end else if bz==nil then return bh(bi,"'completed' callback has to be set for non-streamed requests")elseif bA~=nil or bB~=nil then return bh(bi,"non-streamed requests only support 'completed' callbacks")end end elseif bV~=nil then return bh(bi,"options.stream_response has to be of type boolean")end;if bA~=nil or bB~=nil then aZ[bi]=bA or false;if bA~=nil then if not aY then n(ad,bt)aY=true end end;b0[bi]=bB or false;if bB~=nil then if not a_ then n(ae,bu)a_=true end end end;local bW=ap()if not bU(bi,bW)then aL(bi)if bz~=nil then bz(false,{status=0,status_message="Failed to send request"})end;return end;if by.priority=="defer"or by.priority=="prioritize"then local aj=by.priority=="prioritize"and aF or aE;if not aj(bi)then return bh(bi,"failed to set priority")end elseif by.priority~=nil then return bh(bi,"options.priority has to be 'defer' of 'prioritize'")end;aW[bi]=bz or false;if bz~=nil then m(bW[0],bo,ac)end end;local function bX(bY)if bY~=nil and type(bY)~="boolean"then return error("allow_modification has to be of type boolean")end;local bZ=aO(bY==true)if bZ~=nil then local a7=ao(bZ)g(a7,bf)local I=setmetatable({},bb)b1[I]=a7;return I end end;local b_={request=bw,create_cookie_container=bX}for bx in pairs(a9)do b_[bx]=function(...)return bw(bx,...)end end;local c0=_G.http;b_.Get=c0.Get;_G.http=b_;callbacks.Register('Unload',function()_G.http=c0 end)